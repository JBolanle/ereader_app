# Session: 2025-12-01

## Accomplished
- Created `playground/` folder for learning and experimentation
- Successfully opened EPUB files as ZIP archives using Python's `zipfile` module
- Parsed `META-INF/container.xml` to understand EPUB structure
- Learned XML parsing with `xml.etree.ElementTree`
- Handled XML namespaces using XPath syntax (`.//{*}tagname`)
- Successfully extracted the path to `content.opf` from container.xml
- Understood the EPUB navigation flow: `container.xml` → `content.opf` → metadata/manifest/spine

## Decisions Made
- **Use ElementTree over lxml**: Starting with the standard library for XML parsing; sufficient for EPUB files and better for learning fundamentals
- **Use forgiving XPath patterns**: Opted for `.//{*}tagname` syntax to handle namespaces robustly, making code work with various EPUB files in the wild
- **Playground approach**: Created separate folder for experimentation before integrating into main codebase

## Open Questions
- None at this stage - next step is clear

## Next Session
- [ ] Extract title and author from `content.opf` file
- [ ] Parse metadata section (tags: `<dc:title>`, `<dc:creator>`)
- [ ] Handle namespaces in the OPF file
- [ ] Consider extracting other metadata (publisher, date, language)
- [ ] After metadata: explore the spine (reading order) and manifest (file list)

## Learned Today
- **File extensions are just labels**: `.epub` files are literally ZIP files; the extension just tells the OS what app to use
- **XML namespaces**: Real-world XML uses namespaces (like `{urn:oasis:...}tagname`) to prevent tag name collisions; can use `{*}` wildcard to ignore them
- **XPath basics**: `.` = current element, `//` = search recursively, `.//{*}tag` = find tag at any depth with any namespace
- **EPUB structure**: Container.xml points to OPF file, OPF contains metadata/manifest/spine, actual content is in HTML/XHTML files
- **Spine vs ToC**: Spine is reading order (in OPF), Table of Contents is human-readable navigation (separate file)
- **Context managers**: Properly used nested `with` statements for both ZIP files and files within archives
- **Bytes vs strings**: Files from ZIP come as bytes; need `.decode('utf-8')` for text content

## Code Highlights
- Successfully navigated XML namespaces on first encounter
- Clean use of context managers for resource handling
- Good debugging approach (adding print statements to understand structure)

## CLAUDE.md Updates
- Updated Current Sprint section with EPUB parsing progress
- Added decisions to Decisions Log
